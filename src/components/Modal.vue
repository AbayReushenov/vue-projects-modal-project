<!--
## @click.self

<div class="backdrop" @click.self="closeModal">

Клик только на самом backdrop (не на дочерних элементах) закрывает модалку
Практический результат:
Это улучшает UX, так как пользователь может:
Кликнуть на фон, чтобы закрыть модалку (ожидаемое поведение)
Взаимодействовать с содержимым модалки без случайного закрытия
Модификатор .self очень полезен для создания "оверлеев" и "бэкдропов", которые должны
закрываться только при клике именно на них, а не на их содержимое.
 -->

<template>
  <div class="backdrop" @click.self="closeModal">
    <div class="modal" :class="{ sale: theme === 'sale' }">
      <h1>{{ header }}</h1>
      <p>{{ text }}</p>
    </div>
  </div>
</template>
<!--
Есть метод closeModal, который вызывается при клике на backdrop (фон модального окна).
Внутри этого метода вызывается this.$emit('close').
Это генерирует пользовательское событие с именем close.

$emit позволяет дочернему компоненту (Modal) инициировать изменения в родительском компоненте
(App) без прямого изменения родительских данных, обеспечивая односторонний поток данных.
Это соответствует принципам реактивности и композиции Vue.js.

Когда пользователь кликает на фон модального окна (backdrop), в Modal вызывается closeModal.
closeModal генерирует событие close с помощью $emit.

Родительский компонент App ловит это событие через @close и выполняет метод toggleModal.
toggleModal переключает значение showModal между true и false, что управляет отображением модального окна.

Мы используем $emit для генерации события с именем close. В родительском компоненте мы слушаем это событие с помощью @close (или v-on:close).
Имя события, которое мы используем в $emit, должно совпадать с именем, которое мы используем в родительском компоненте для прослушивания.

В данном случае, в дочернем компоненте (Modal.vue) мы генерируем событие с именем 'close':
this.$emit('close')

В родительском компоненте (App.vue) мы слушаем это событие с помощью @close:
<Modal @close="toggleModal" />

Если мы хотим использовать другое имя события, мы можем изменить его в обоих местах.

Например, мы можем изменить в Modal.vue:
this.$emit('close-modal')

Тогда в App.vue мы должны слушать событие с именем 'close-modal':
<Modal @close-modal="toggleModal" />

Важно, чтобы имя события в $emit и в обработчике в родительском компоненте совпадали.

Однако, note: в Vue 3 рекомендуется использовать kebab-case для имен событий в шаблонах (как и для props).
Но в самом JavaScript коде (в методе closeModal) мы пишем это в camelCase или kebab-case?
В самом $emit мы пишем строку, и обычно используют kebab-case для имен событий, потому что в HTML атрибуты не чувствительны к регистру.

Но note: в Vue 3, при использовании в шаблоне, мы можем использовать как kebab-case, так и camelCase для прослушивания событий, но обычно используют kebab-case.

Однако, в данном примере в родительском компоненте мы используем @close, а в дочернем $emit('close').
Если мы хотим изменить на close-modal, то:

В Modal.vue:
methods: {
closeModal() {
this.$emit('close-modal')
}
}

В App.vue:
<Modal @close-modal="toggleModal" />

Но note: в компоненте Modal мы также имеем prop с именем 'header', 'text', 'theme'. И мы передаем их в Modal из App.vue.
Это не связано с событиями.

Итак, да, событие может быть названо по-другому, главное, чтобы в дочернем компоненте при генерации и в родительском при прослушивании использовалось одно и то же имя.-->
<script>
export default {
  props: ['header', 'text', 'theme'],
  methods: {
    closeModal() {
      this.$emit('close') // кастомное событие, подвязываем через $emit  22 41
    }
  }
}
</script>

<style>
.modal {
  width: 400px;
  padding: 20px;
  margin: 100px auto;
  background: white;
  border-radius: 10px;
}

.backdrop {
  top: 0;
  position: fixed;
  background: rgba(0, 0, 0, 0.5);
  width: 100%;
  height: 100%;
}

.modal h1 {
  color: #03cfb4;
  border: none;
  padding: 0;
}

.modal p {
  font-style: normal;
}

.modal.sale {
  background: crimson;
  color: white;
}

.modal.sale h1 {
  color: white
}
</style>
